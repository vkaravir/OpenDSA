<!DOCTYPE html>
<html>
  <head>
    <title>Binary Heap Delete</title>
    <link rel="stylesheet" href="../../JSAV/css/JSAV.css" type="text/css" media="screen" title="no title" charset="utf-8" />
    <link rel="stylesheet" href="../opendsaAV.css" type="text/css" />
    <style>
    #av { width: auto;}
    .jsavcontrols a { margin-left: 0;}
    #decrement { margin-right: 20px;}
    .jsavline { height: 45px; margin: 0 0 0 20px; }
    </style>
  </head>
  <body>
    <div id="container">
      <form class="avcontainer">
        <div class="jsavcanvas">
          <p class="instructLabel">Instructions:</p>
          <p class="instructions">
            Perform DeleteMin three times, and after each deletion, restore heap property. For each record stored into heap you can see a key that corresponds to the priority. <br/><br/>"Decrement heap size" -button will delete the last key of the heap. In addition, by first clicking one key and then another, you can swap the records.
          </p>
          <p align="center">
            <input id="decrement" type="button" value="Decrement heap size"/>
            <span class="jsavexercisecontrols"></span>
            <span class="jsavscore"></span>
          </p>
        </div>
      </form>
    </div>
    
    <script
       src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js">
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
    <script src="../../JSAV/lib/jquery.transform.light.js"></script>
    <script src="../../JSAV/lib/raphael.js"></script>
    <script src="../../JSAV/build/JSAV-min.js"></script>
    <script src="../../JSAV/extras/binaryheap.js"></script>
    <script src="../../lib/ODSA.js"></script>
    <script src="../opendsaAV.js"></script>

    <script>
    var initData, bh,
        jsav = new JSAV($(".avcontainer")),
        swapIndex;

    jsav.recorded();
    function init() {
      var nodeNum = 15;
      if (bh) {
        bh.clear();
        swapIndex.element.remove();
      }
      $.fx.off = true;
      var test = function(data) {
        var min = 1000,
            mmax = Math.max;
        // make sure we get a collision
        data[1] = data[2];
        bh = jsav.ds.binheap(data, {size: nodeNum, stats: true, tree: false});
        bh.stats.swaps = 0;
        var swapsBefore = 0,
            maxRecursion = 0;
        for (var i = 0; i < 3; i++) {
          bh.swap(0, bh.heapsize() - 1);
          bh.element.attr("data-jsav-heap-size", bh.heapsize() - 1);
          bh.heapify(1);
          maxRecursion = mmax(maxRecursion, bh.stats.swaps - swapsBefore);
          swapsBefore = bh.stats.swaps;
        }
        var swaps = bh.stats.swaps;
        bh.clear();
        return !(swaps < 7 || swaps > 10 || !bh.stats.interrupted || maxRecursion < 3);
      };
      initData = JSAV.utils.rand.numKeys(10, 100, nodeNum, {test: test, tries: 50});
      initData = JSAV.utils.rand.numKeys(10, 100, nodeNum);
      bh = jsav.ds.binheap(initData);
      swapIndex = jsav.variable(-1);
      $.fx.off = false;
      return bh;
    }
    
    function model(modeljsav) {
      modelbh = modeljsav.ds.binheap(initData, {nodegap: 20});
      modelbh.origswap = modelbh.swap; // store original heap grade function
      // set all steps gradeable that include a swap
      modelbh.swap = function (ind1, ind2, opts) {
        this.origswap(ind1, ind2, opts);
        this.jsav.stepOption("grade", true);
      };
      modeljsav._undo = [];
      var count = 3;
      while (count > 0) {
        if (count === 3) {
          modeljsav.umsg("We start by swapping smallest (first) and last items in heap.");
          modeljsav.step();
        } else if (count === 2) {
          modeljsav.umsg("Again, we swap smallest and last items in heap.");
        } else {
          modeljsav.umsg("...swap smallest and last items in heap.");
        }
        modelbh.swap(0, modelbh.heapsize() - 1);
        modelbh.element.attr("data-jsav-heap-size", modelbh.heapsize() - 1);
        modeljsav.step();

        modeljsav.umsg("<br/>...decrement the heap size", {preserve: true});
        modelbh.css(modelbh.heapsize(), {"opacity": "0"})
        modelbh._treenodes[modelbh.heapsize()].edgeToParent().css("stroke", "white");
        modeljsav.stepOption("grade", true);
        modeljsav.step();
        modeljsav.umsg("<br/>...and restore the heap property", {preserve: true});
        modelbh.heapify(1);
        count--;
      }
      modeljsav.umsg("");
      return modelbh;
    }
    var exercise = jsav.exercise(model, init, {css: "opacity"}, { modelDialog: {width: "95%"} });
    exercise.reset();
    
    function clickHandler(index) {
      jsav._redo = []; // clear the forward stack, should add a method for this in lib
      var sIndex = swapIndex.value();
      if (sIndex === -1) { // if first click
        bh.css(index, {"font-size": "145%"});
        swapIndex.value(index);
        jsav.step();
      } else if (index === sIndex) { // second click on same
        bh.css(index, {"font-size": "100%"});
        swapIndex.value(-1);
        jsav.step();
      } else { // second click will swap
        bh.swap(sIndex, index, {});
        bh.css([sIndex, index], {"font-size": "100%"});
        jsav.logEvent({type: "jsav-heap-swap", arrayid: bh.id(), index1: sIndex, index2: index});
        swapIndex.value(-1);
        exercise.gradeableStep();
      }
    }
    $(".jsavcontainer").on("click", ".jsavarray .jsavindex", function() {
      var index = $(this).parent(".jsavarray").find(".jsavindex").index(this);
      jsav.logEvent({type: "jsav-heaparray-click", arrayid: bh.id(), index: index});
      clickHandler(index);
    });
    $(".jsavcontainer").on("click", ".jsavbinarytree .jsavbinarynode", function() {
      var index = $(this).data("jsav-heap-index") - 1;
      jsav.logEvent({type: "jsav-heaptree-click", arrayid: bh.id(), index: index});
      clickHandler(index);
    });
    $("#decrement").click(function() {
      bh.heapsize(bh.heapsize() - 1);
      bh.css(bh.heapsize(), {"opacity": "0"});
      bh._treenodes[bh.heapsize()].edgeToParent().css("stroke", "white");
      jsav.logEvent({type: "jsav-heap-decrement", newSize: bh.heapsize()});
      if (swapIndex.value() !== -1) {
        swapIndex.value(-1);
      }
      exercise.gradeableStep();
    });
    </script>
  </body>
</html>
